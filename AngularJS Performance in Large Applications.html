<!doctype html><div style="max-width: 700px;font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif;padding: 50px;line-height: 1.25;background: #f9f9f9;"><meta charset="UTF8"/><title>AngularJS Performance in Large Applications</title><h1>AngularJS Performance in Large Applications</h1><p><a href="https://www.airpair.com/angularjs/posts/angularjs-performance-large-applications?">Original Article</a> &middot; <a href="#articleList">Articles in this issue</a> </p><div><post><h2 id="1-introduction">1 Introduction</h2>
<p>Whether you are writing an Angular front end for an old application with large use and adoption, or your pre-existing Angular application is gaining momentum, performance is an important aspect. It is important to understand what causes an AngularJS application to slow down, and to be aware of tradeoffs that are made in the development process. This article will walk through some of the more common performance problems caused by AngularJS as well as given suggestions on how to fix and avoid them in the future.</p>
<h3 id="1-1-requirements-assumptions">1.1 Requirements, Assumptions</h3>
<p>This article is going to assume some familiarity with the JavaScript programming language and AngularJS. When version-specific features are used, they will be called out as such. To really get the most out of this article, it would be best if you had spent some time playing with Angular, but had not yet seriously tackled performance.</p>

<h3 id="2-1-benchmarking">2.1 Benchmarking</h3>
<p>A fantastic tool for benchmarking one's code is <a href="http://www.jsperf.com">jsPerf</a>. I will link to specific test runs at the end of relevant sections for readability.</p>
<h3 id="2-2-profiling">2.2 Profiling</h3>
<p>The Chrome Dev Tools have a fantastic Javascript profiler. I highly recommend reading <a href="https://developer.chrome.com/devtools/docs/network">this series</a> of articles.</p>
<h3 id="2-3-angular-batarang">2.3 Angular Batarang</h3>
<p>A dedicated Angular debugger is maintained by the Angular Core Team and <a href="https://github.com/angular/angularjs-batarang">available on GitHub</a>.</p>

<p>There are two fundamental causes of non-performant software. </p>
<p>The first is algorithmic time complexity. Fixing this problem is largely outside the scope of this article, suffice it to say that in general time complexity is a measure of how many comparisons a program needs to make to achieve a result. The larger the number of comparisons, the slower the program. A simple example is linear search vs. binary search. Linear search needs to make more comparisons for the same set of data, and will therefore be slower. For a detailed discussion of time complexity, refer to the <a href="http://en.wikipedia.org/wiki/Time_complexity">Wikipedia article</a>.</p>
<p>The second reason software is slow is known as space complexity. This is a measure of how much 'space' or memory a computer needs to run your solution. The more memory required, the slower the solution. Most of the problems this article will talk to fall loosely under space complexity. For a detailed discussion, <a href="http://www.leda-tutorial.org/en/official/ch02s02s03.html">see here</a>.</p>

<p>There are several things to be said about performant Javascript that are not necessarily limited to Angular. </p>
<h3 id="4-1-loops">4.1 Loops</h3>
<p>Try and avoid making calls in a loop. Any call that can be done once outside a loop will dramatically speed up your system. For example:</p>


<pre><code>var sum = 0;
for(var x = 0; x &lt; 100; x++){
  var keys = Object.keys(obj);
  sum = sum + keys[x];
}
</code></pre><p>Will be dramatically slower than:</p>


<pre><code>var sum = 0;
var keys = Object.keys(obj);
for(var x = 0; x &lt; 100; x++){
  sum = sum + keys[x];
}
</code></pre><p><a href="http://jsperf.com/for-loop-perf-demo-basic">http://jsperf.com/for-loop-perf-demo-basic</a></p>
<h3 id="4-2-dom-access">4.2 Dom access</h3>
<p>It is important to note that accessing the DOM...</p>


<pre><code>angular.element('div.elementClass')
</code></pre><p>...is expensive. While this should rarely be a problem in AngularJS, it is still useful to be aware of this. The second thing to say here, is that when possible, the DOM tree should be kept small. </p>
<p>Finally, if at all possible avoid modifying the DOM, and do not set inline styles. This is due to JavaScript reflow. An in depth discussion of reflow is out of scope for this article, but a fantastic reference can be <a href="http://www-archive.mozilla.org/newlayout/doc/reflow.html">found here</a>.</p>
<h3 id="4-3-variable-scope-and-garbage-collection">4.3 Variable Scope and Garbage Collection</h3>
<p>Scope all variables as tightly as possible to allow the JavaScript garbage collector to free up your memory sooner rather then later. This is an exceedingly common cause of slow, laggy, non-responsive JavaScript in general and Angular in particular. Be aware of the following problems:</p>


<pre><code>  function demo(){
    var b = {childFunction: function(){console.log('hi this is the child function')};
    b.childFunction();
    return b;
  }
</code></pre><p>When the function terminates, there will be no further references to <code>b</code> available, and the garbage collector will free up the memory. However, if there is a line elsewhere like so:</p>


<pre><code>var cFunc = demo();
</code></pre><p>We now bind the object to a variable and maintain reference to it, preventing the garbage collector from cleaning it up. While this may be necessary, it is important to be aware of what effect you are having on object references.</p>
<h3 id="4-4-arrays-and-objects">4.4 Arrays and Objects</h3>
<p>There are many things to talk about. The first and simplest is that arrays are always faster then objects, and numeric access is better then non-numeric access.</p>


<pre><code>for (var x=0; x&lt;arr.length; x++) {
    i = arr[x].index;
}
</code></pre><p>is faster then</p>


<pre><code>(var x=0; x&lt;100; x++) {
    i = obj[x].index;
}
</code></pre><p>which is still faster then</p>


<pre><code>var keys = Object.keys(obj);
for (var x = 0; x &lt; keys.length; x++){
  i = obj[keys[x]].index;
}
</code></pre><p><a href="http://jsperf.com/array-vs-object-perf-demo">http://jsperf.com/array-vs-object-perf-demo</a></p>
<p>Furthermore, be aware that in modern, V8-based browsers, objects with few properties get a special representation that is significantly faster, so try and keep the number of properties to a minimum.
Also be aware that just because JavaScript lets you mix types in an array does not make it a good idea:</p>


<pre><code>var oneType=[1,2,3,4,5,6]
var multiType=["string", 1,2,3, {a: 'x'}]
</code></pre><p>Any operation on the second will be significantly slower then the first, and not just because the logic needs to be more complex.</p>
<p><a href="http://jsperf.com/array-types-compare-perf">http://jsperf.com/array-types-compare-perf</a></p>
<p>Also Avoid using <code>delete</code>. For example, given:</p>


<pre><code>var arr = [1,2,3,4,5,6];
var arrDelete = [1,2,3,4,5,6];
delete arrDelete[3];
</code></pre><p>Any iteration of <code>arrDelete</code> will be slower then an identical iteration over <code>arr</code>.</p>
<p><a href="http://jsperf.com/delet-is-slow">http://jsperf.com/delet-is-slow</a></p>
<p>This will create a hole in the array making operations much less efficient.</p>
<h2 id="5-important-concepts">5 Important Concepts</h2>
<p>Now that we have discussed JavaScript performance, it is important to understand a few key Angular concepts that are somewhat "under the hood".</p>
<h3 id="5-1-scopes-and-the-digest-cycle">5.1 Scopes and the Digest Cycle</h3>
<p>At their core, Angular scopes are simply JavaScript objects. They follow a predefined prototypical inheritance scheme, an in-depth discussion of which is outside the scope of this article. What is relevant, is that as outlined above, small scopes will be faster then large scopes. </p>
<p>Another observation that can be made at this point, is that any time a new scope is created, that adds more values for the garbage collector to collect "later".</p>
<p>Of particular importance to writing Angular JS applications in general and performance in particular is the digest cycle. Effectively, every scope stores an array of functions <code>$$watchers</code>. </p>
<p>Every time <code>$watch</code> is called on a scope value, or a value is bound from the DOM with interpolation, an <code>ng-repeat</code>, an <code>ng-switch</code>, and <code>ng-if</code>, or any other DOM attribute/element, a function gets added to the <code>$$watchers</code> array of the innermost scope. </p>
<p>When any value in scope changes, all watchers in the <code>$$watchers</code> array will fire, and if any of them modify a watched value, they will all fire again. This will continue until a full pass of the <code>$$watchers</code> array makes no changes, or AngularJS throws an exception. </p>
<p>Additionally, if non-Angular code is run through <code>$scope.$apply()</code>, this will immediately kickstart the digest cycle. </p>
<p>The final note is that <code>$scope.evalAsync()</code> will run code in an async loop that does NOT trigger another digest cycle, and which will run at the end of the current/next digest cycle.</p>
<h2 id="6-common-problems-design-with-angular-in-mind">6 Common Problems: Design with Angular in mind</h2>
<h3 id="6-1-large-objects-and-server-calls-">6.1 Large Objects and Server Calls.</h3>
<p>So what does all of this teach us? The first is that we should think through our data model and attempt to limit the complexity of our objects. This is especially important for objects that are returned from the server. </p>
<p>It is very tempting to simply lob an entire database row over the fence, so to speak, with an eyeroll and an obligatory <code>.toJson()</code>. This can not be stressed enough: <strong>don't do that</strong>.</p>
<p>Instead use a custom serializer to only return the subset of keys that your Angular application absolutely must have.</p>
<h3 id="6-2-watching-functions">6.2 Watching Functions</h3>
<p>Another common problem is the utilization of functions in watchers or bindings. <strong><em>Never</em></strong> bind anything (<code>ng-show</code>, <code>ng-repeat</code>, etc.) directly to a function. <strong><em>Never</em></strong>  watch a function result directly. This function will run on <strong><em>every</em></strong> digest cycle, possibly slowing your application to a crawl. </p>
<h3 id="6-3-watching-objects">6.3 Watching Objects</h3>
<p>Similarly, Angular provides the ability to watch entire objects by passing a third, optional <code>true</code> parameter to <code>scope.$watch</code>. This is, for lack of better words, a <strong><em>terrible</em></strong> idea. A much better solution is to rely on services and object references to propagate object changes between scopes.</p>
<h2 id="7-list-problems">7 List Problems</h2>
<h3 id="7-1-long-lists">7.1 Long Lists</h3>
<p>If at all possible, avoid long lists. <code>ng-repeat</code> does some pretty heavy DOM manipulation (not to mention polluting <code>$$watchers</code>), so try and keep any lists of rendered data small whether through pagination or  infinite scroll.</p>
<h3 id="7-2-filters">7.2 Filters</h3>
<p>Avoid using filters if at all possible. They are run twice per digest cycle, once when anything changes, and another time to collect further changes, and do not actually remove any part of the collection from memory, instead simply masking filtered items with css. </p>
<p>This renders <code>$index</code> worthless as it no longer corresponds to the actual array index, but the sorted array index. It also prevents you from letting go of all of the list's scopes. </p>
<h3 id="7-3-updating-an-ng-repeat-">7.3 Updating an <code>ng-repeat</code></h3>
<p>It is also important to avoid a global list refresh when using <code>ng-repeat</code>. Under the hood, <code>ng-repeat</code> will populate a <code>$$hashKey</code> attribute and identify items in the set by it. What this means is that doing something like <code>scope.listBoundToNgRepeat = serverFetch()</code> will cause a complete recalculation of the entire list, causing transcludes to run and watchers to fire for every individual element. This is a very expensive proposition. </p>
<p>There are two ways around this. One is to maintain two collections and <code>ng-repeat</code> over the filtered set (more generic, requires custom syncing logic, therefore algorithmically more complex and less maintainable), the other is to use <code>track by</code> to specify your own key (requires Angular 1.2+, slightly less generic, does not require custom syncing logic).</p>
<p>In short:</p>


<pre><code>scope.arr = mockServerFetch();
</code></pre><p>Will be slower than:</p>


<pre><code>  var a = mockServerFetch();
    for(var i = scope.arr.length - 1; i &gt;=0; i--){
      var result = _.find(a, function(r){
        return (r &amp;&amp; r.trackingKey == scope.arr[i].trackingKey);
      });
      if (!result){
        scope.arr.splice(i, 1);
      } else {
        a.splice(a.indexOf(scope.arr[i]), 1);
      } 
    }
    _.map(a, function(newItem){
      scope.arr.push(newItem);
     });
</code></pre><p>Which will be slower than simply adding:</p>


<pre><code>&lt;div ng-repeat="a in arr track by a.trackingKey"&gt;
</code></pre><p>In place of:</p>


<pre><code>&lt;div ng-repeat="a in arr"&gt;
</code></pre><p>A fully-functional demo of all three approaches can be found <a href="http://plnkr.co/qRlVT52vaMreEkXvhQ3B">here</a>.</p>
<p>Simply clicking between the three options and asking for a refetch demonstrates the point nicely and obviously. One side note it is important to make is that the track by approach only works when a field on the repeated object can be guaranteed to be unique in the set. For server data, the id attribute serves as a natural tracker. If this is not possible, unfortunately the custom syncing logic is the only way to go.</p>
<h2 id="8-rendering-problems">8. Rendering Problems</h2>
<p>A common source of slow Angular applications is incorrect use of <code>ng-hide</code> and <code>ng-show</code> over <code>ng-if</code> or <code>ng-switch</code>. The distinction is nontrivial, and the importance can not be overstated in the context of performance. </p>
<p><code>ng-hide</code> and <code>ng-show</code> simply toggle the CSS <code>display</code> property. What that means in practice is that anything shown or hidden will still be on the page, albeit invisible. Any scopes will exist, all <code>$$watchers</code> will fire, etc.</p>
<p><code>ng-if</code> and <code>ng-switch</code> actually remove or add the DOM completely. Something removed with <code>ng-if</code> will have no scope. While the performance benefits should by now be obvious, there is a catch. Specifically, it is relatively cheap to toggle the show/hide, but relatively expensive to toggle if/switch. Unfortunately this results in a case by case judgement call. The questions that need to be answered to make this decision are:</p>
<ol>
<li>How frequently will this change? (the more frequent, the worse fit <code>ng-if</code> is).</li>
<li>How heavy is the scope? (the heavyer, the better fit <code>ng-if</code> is).</li>
</ol>
<h2 id="9-digest-cycle-problems">9. Digest Cycle Problems</h2>
<h3 id="9-1-bindings">9.1 Bindings</h3>
<p>Try and minimize your bindings. As of Angular 1.3, there is a new bind once and forget syntax in the shape of <code>{{::scopeValue}}</code>. This will interpolate from scope once without adding a watcher to the watchers array.</p>
<h3 id="9-2-digest-and-apply-">9.2 <code>$digest()</code> and  <code>$apply()</code></h3>
<p><code>scope.$apply</code> is a powerful tool that allows you to introduce values from outside Angular into your application. It is fired under the hood by angular on all of its events (<code>ng-click</code>, etc). The problem arises in the fact that <code>scope.$apply</code> starts at <code>$rootScope</code> and walks the entire scope chain causing every scope to fire every watcher. </p>
<p><code>scope.$digest</code> on the other hand starts at the specific scope calling it, and only walks down from there. The performance benefit should be fairly self evident. The trade off, of course, is that any parent scopes will not receieve this update until the next digest cycle.</p>
<h3 id="9-3-watch-">9.3 <code>$watch()</code></h3>
<p><code>scope.$watch()</code> has now been discussed on several occasions. In general, <code>scope.$watch</code> is indicative of bad architecture. There are very few cases when some combination of services and reference bindings can not achieve the same results with lower overhead. If you must create a watcher, always remember to unbind it at the first available opportunity. You can unbind a watcher by calling the unbinding function returned by <code>$watch</code>. </p>


<pre><code>var unbinder = scope.$watch('scopeValueToBeWatcher', function(newVal, oldVal){});
unbinder(); //this line removes the watch from $$watchers.
</code></pre><p>If you can not unbind earlier then that, remember to unbind in your <code>$on('$destroy')</code></p>
<h3 id="9-4-on-broadcast-and-emit-">9.4 <code>$on</code>, <code>$broadcast</code>  , and <code>$emit</code></h3>
<p>Like <code>$watch</code>, these are slow as events (potentially) have to walk your entire scope hierarchy. On top of this, being glorified <code>GOTO</code>, they can make your application a convoluted mess to debug. Luckily, like with <code>$watch</code>, they can be unbound with the returned function if absolutely necessary (remember to unbind your <code>$on('$destroy')</code> in your <code>$on('$destroy')</code> and can almost always be avoided outright with judicious use of services and scope inheritance.</p>
<h3 id="9-5-destroy-">9.5 <code>$destroy</code></h3>
<p>As outlined above, you should always explicitly call your <code>$on('$destroy')</code>, unbind all your watchers and event listeners, and cancel any instances of <code>$timeout</code>, or other asynchronous ongoing interactions. This is not only good practice to ensure safety, and flag your scope for garbage collection more rapidly. Not doing so will keep them running in the background, wasting your CPU and RAM.</p>
<p>It is especially important to remember to unbind any DOM event listeners defined on a directives element in the <code>$destroy</code> call. Failing to do so will cause memory leaks in older browser, and slow down your Garbage Collector in modern browsers. A very important corollary is that you need to remember to call <code>scope.$destroy</code> before you remove the DOM.</p>
<h3 id="9-6-evalasync-">9.6 <code>$evalAsync</code></h3>
<p><code>scope.$evalAsync</code> is a powerful tool that lets you queue operations up for execution at the end of the current digest cycle without marking the scope dirty for another digest cycle. This needs to be thought about on a case by case basis, but where that is the desired effect, <code>evalAsync</code> can greatly improve your page's performance.</p>
<h2 id="10-directive-problems">10 Directive Problems</h2>
<h3 id="10-1-isolate-scope-and-transclusion">10.1 Isolate Scope and Transclusion</h3>
<p>Isolate Scope and Transclusion are some of the most exciting things about Angular. They allow the building of reusable, encapsulated components, they are syntactically and conceptually elegant and a core part of what makes Angular Angular. </p>
<p>However, they come with a tradeoff. By default, directives do not create a scope, instead occupying the same scope as their parent element. By creating a new scope with Isolate Scope or Transclusion, we are creating a new object to track, adding new watchers, and therefore slowing down our application. Always stop and think before you use either of these techniques.</p>
<h3 id="10-2-the-compile-cycle">10.2 The compile cycle</h3>
<p>Directive's <code>compile</code> functions run before scope is attached and are the perfect place to run any DOM manipulations (binding events for example). The important thing to recognize from a performance point of view, is that the element and attributes passed into the <code>compile</code> function represent the raw html template, before any of angular's changes have been made. What this means in practice is that DOM manipulation done here, will run once, and propagate always.
Another important point that is frequently glossed over is the difference between <code>prelink</code> and <code>postlink</code>. In short, prelinks run from the outside in, while postlinks run from the inside out. As such, prelinks offer a slight performance boost, as they prevent the inner directives from running a second digest cycle when the parent modifies scope in the prelink. However, child DOM may not yet be available.</p>
<h2 id="11-dom-event-problems">11 DOM Event Problems</h2>
<p>Angular provides many pre-rolled DOM event directives. <code>ng-click</code>, <code>ng-mouseenter</code>, <code>ng-mouseleave</code>,etc.
All of these call <code>scope.$apply()</code> every time the event occurs. A much more efficient approach is to bind directly with <code>addEventListener</code>, and then use <code>scope.$digest</code> as necessary.</p>

<h3 id="12-1-angularjs-the-bad-parts">12.1 AngularJS: The bad parts</h3>
<ul>
<li>ng-click and other DOM events</li>
<li>scope.$watch</li>
<li>scope.$on</li>
<li>Directive postLink</li>
<li>ng-repeat</li>
<li>ng-show and ng-hide</li>
</ul>

<ul>
<li>track by</li>
<li>oneTime bindings with ::</li>
<li>compile and preLink</li>
<li>$evalAsync</li>
<li>Services, scope inheritance, passing objects by reference</li>
<li>$destroy</li>
<li>unbinding watches and event listeners</li>
<li>ng-if and ng-switch</li>
</ul>
</post>

  </div><hr/><section id="articleList" style="font-size: 14px;"><b>Articles in This Issue</b><ul><li><a href="./Meta Programming with ECMAScript 6 Proxies.html">Meta Programming with ECMAScript 6 Proxies</a></li><li><a href="./AngularJS Performance in Large Applications.html">AngularJS Performance in Large Applications</a></li><li><a href="./What Is The Flux Application Architecture?.html">What Is The Flux Application Architecture?</a></li><li><a href="./An easier way to deploy &amp; host your Rails app – for free..html">An easier way to deploy &amp; host your Rails app – for free.</a></li><li><a href="./<img src="http:--s3.amazonaws.com-nlga-uploads-item-image-24793-i.png" style="border: 0px solid #bbbbbb" width="" height="" alt="Ninefold">.html"><img src="http://s3.amazonaws.com/nlga/uploads/item/image/24793/i.png" style="border: 0px solid #bbbbbb" width="" height="" alt="Ninefold"></a></li><li><a href="./16 Steps for Planning A Front-End JavaScript Application.html">16 Steps for Planning A Front-End JavaScript Application</a></li><li><a href="./Node.js Is Forked, Not F***ed.html">Node.js Is Forked, Not F***ed</a></li><li><a href="./Programmer Extraordinaire..html">Programmer Extraordinaire.</a></li><li><a href="./JavaScript Developers, AngularJS-Node.js (Berlin).html">JavaScript Developers, AngularJS/Node.js (Berlin)</a></li><li><a href="./President Obama Writes His First Line of JavaScript.html">President Obama Writes His First Line of JavaScript</a></li><li><a href="./ES6 Template Strings Working in Chrome.html">ES6 Template Strings Working in Chrome</a></li><li><a href="./Ember.js 1.9.0 and 1.10 Beta Released.html">Ember.js 1.9.0 and 1.10 Beta Released</a></li><li><a href="./'JavaScript for Kids' Book Released.html">'JavaScript for Kids' Book Released</a></li><li><a href="./Making A Complete Polyfill For The HTML5 'details' Element.html">Making A Complete Polyfill For The HTML5 'details' Element</a></li><li><a href="./Techniques for Building Web Apps using Future Friendly ES6 Module Syntax.html">Techniques for Building Web Apps using Future Friendly ES6 Module Syntax</a></li><li><a href="./Effective Event Binding with jQuery.html">Effective Event Binding with jQuery</a></li><li><a href="./Five Traits of Well-Organized JavaScript.html">Five Traits of Well-Organized JavaScript</a></li><li><a href="./Porting An Entire Desktop Toolchain to The Browser with Emscripten.html">Porting An Entire Desktop Toolchain to The Browser with Emscripten</a></li><li><a href="./The State of Desktop Applications in Node.js.html">The State of Desktop Applications in Node.js</a></li><li><a href="./thaw.js: Synthetic Asynchronous Processing.html">thaw.js: Synthetic Asynchronous Processing</a></li><li><a href="./FiltrES.js: A Simple, Safe, ElasticSearch Query Compiler.html">FiltrES.js: A Simple, Safe, ElasticSearch Query Compiler</a></li><li><a href="./Angular 2.0 Hello World Example.html">Angular 2.0 Hello World Example</a></li><li><a href="./Purplecoat.js: Simple Labeled Overlays (jQuery Plugin).html">Purplecoat.js: Simple Labeled Overlays (jQuery Plugin)</a></li><li><a href="./dstore: A Client-Side Data Management Framework with Multiple Store Types.html">dstore: A Client-Side Data Management Framework with Multiple Store Types</a></li><li><a href="./bigpicture.js: A Library for Prezi-esque Infinite Panning and Infinite Zooming.html">bigpicture.js: A Library for Prezi-esque Infinite Panning and Infinite Zooming</a></li><li><a href="./decimal.js: An Arbitrary-Precision Decimal Type for JavaScript.html">decimal.js: An Arbitrary-Precision Decimal Type for JavaScript</a></li></ul></section></div>