<!doctype html><div style="max-width: 700px;font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif;padding: 50px;line-height: 1.25;background: #f9f9f9;"><meta charset="UTF8"/><title>Knowing Which Apps You’re Breaking using Static Analysis</title><h1>Knowing Which Apps You’re Breaking using Static Analysis</h1><p><a href="http://mrjoelkemp.com/2015/01/javascript-knowing-which-apps-youre-breaking-using-static-analysis/?">Original Article</a> &middot; <a href="#articleList">Articles in this issue</a> </p><div><div class="entry-content">
			<p>When you join&#xA0;large projects and fix bugs or build features, you&#xA0;typically rely on senior (in terms of time at the company) engineers to say &#x201C;don&#x2019;t forget to test feature X (that you probably didn&#x2019;t know existed).&#x201D;</p>
<p>Being new, you have limited knowledge of the entire architecture.&#xA0;Our tools should help fill this gap in knowledge. Our tools should help us traverse and understand large application architectures: the primary reason why I built and continue to work on the&#xA0;<a href="https://packagecontrol.io/packages/Dependents" target="_blank" rel="nofollow">Sublime Dependents</a>&#xA0;plugin.</p>
<p>I recently implemented a new feature&#xA0;that allows you to better understand which features or pages would break with a change to a module by showing you which app entry points depend on that module. In this post, I&#x2019;ll talk&#xA0;about some of the tools and performance considerations that went into building this feature.</p>

<p><strong>Motivation</strong></p>
<p>At B&#x113;hance, we have a multi-bundle JavaScript architecture: where each feature/page has its own (built via rjs) bundle. This allows us to avoid a monolithic&#xA0;bundle and only ship code that&#x2019;s necessary for a given page&#x2019;s features.</p>
<p>Sublime Dependents already has the ability to see which files directly require/import the current file that you&#x2019;re modifying, but that&#x2019;s not enough. Often, it&#x2019;s not just a question of which modules use this module, but which apps/features use this module.</p>
<p><strong>Dependents of a Dependent&#x2019;s Dependents</strong></p>
<p>What we&#x2019;d like to do is uncover each layer of the dependency tree &#x2013; starting with the module that we&#x2019;re modifying. The feature&#xA0;for finding the dependents of the current file does just that. However, we&#x2019;d have to perform this once for the current file, then for every one of those dependents. We&#x2019;d repeat this process recursively until we hit scripts that are entry points (i.e., driver scripts) to the application. The entry points that were reached in the dependency tree of the current module are the &#x201C;relevant entry points&#x201D; that the feature should display.</p>
<p>This is an outward approach to finding the results &#x2013; starting from the module and going out to the ends of the dependency tree until we hit roots. Though this would work, it would take a large number of redundant iterations across all JS files to uncover each layer of the outwardly-growing tree.</p>
<p>Even with the <a href="http://mrjoelkemp.com/2014/12/javascript-squeezing-performance-out-of-dependents/" target="_blank">continued performance enhancements</a>&#xA0;that I&#x2019;m making to get the &#x201C;finding of the dependents&#x201D; to be as fast as possible, that execution time (currently ~2s) is multiplied by a large factor with this approach.</p>
<p><strong>Going from the Outside in</strong></p>
<p>Another approach is to start from the total set of driver scripts and work our way in to find the current module. This method requires a few&#xA0;steps:</p>
<ol>
<li>Programmatically find all driver scripts (i.e., entry points)</li>
<li>For each driver, generate its dependency tree</li>
<li>If the current module is in the dependency tree for a driver, that driver should be in the set of &#x201C;relevant&#x201D; drivers</li>
</ol>
<p>Each step resulted in a new npm module:</p>
<ul>
<li><a href="https://github.com/mrjoelkemp/node-app-root" target="_blank" rel="nofollow">app-root</a> for automatically finding the application&#x2019;s entry points</li>
<li><a href="https://github.com/mrjoelkemp/node-dependency-tree" target="_blank" rel="nofollow">dependency-tree</a> for generating the dependency tree for a given module</li>
<li><a href="https://github.com/mrjoelkemp/node-taxicab" target="_blank" rel="nofollow">taxicab</a> for a (relevant) driver(s)</li>
</ul>
<p><strong>Programmatically Finding the Roots of an Application</strong></p>
<p>I wrote about <a href="http://mrjoelkemp.com/2014/06/js-auto-generate-grunt-tasks-using-static-analysis/" target="_blank">how to do this</a> when building <a href="https://github.com/mrjoelkemp/ya" target="_blank" rel="nofollow">YA</a> to auto-generate the configuration for grunt&#x2019;s requirejs and browserify plugins. The gist of the algorithm is that a root is a module that no other module requires.</p>
<p>It turns out that this simple definition yielded a new edge case that I hadn&#x2019;t thought of when building YA: test files are also roots.</p>
<p>Every test file is a module that has its own dependency tree (typically pulling in the module its testing plus all of that module&#x2019;s dependencies) and no other module requires/imports that test.</p>
<p>You could sniff the AST of a file to determine if it&#x2019;s a test (looking for CallExpressions with names like &#x2018;it&#x2019;, &#x2018;describe&#x2019;, &#x2018;beforeEach&#x2019;, and &#x2018;afterEach&#x2019;. However, I&#x2019;ve opted to ignore these false positives for now. Despite the fact that the dependency trees for these false positives have to be generated in step 2, the way in which the dependency trees are computed yield no redundant computations.</p>
<p><strong>Generating the Dependency Tree of a Module</strong></p>
<p>The algorithm for this is pretty textbook: a recursive, graph traversal &#x2013; collecting the dependencies (via <a href="https://github.com/mrjoelkemp/node-precinct" target="_blank" rel="nofollow">precinct</a>) of every visited module until we hit leaf nodes (i.e., modules that have no dependencies). Dependency trees can also have cycles &#x2013; which need to be avoided during the traversal.</p>
<p>If you took every found driver script from step 1 and ran this tree generation algorithm, you&#x2019;d perform a lot of redundant traversals and dependency extractions&#xA0;&#x2013; particularly across core, heavily-reused application modules. The solution for this is also pretty textbook: memoization.</p>
<p>On our way back up from the recursion we remember the dependency tree so far for each visited module. This uses a bit of memory (caching&#xA0;potentially long lists of absolutely-pathed strings), but that&#x2019;s the tradeoff to get this process as fast as possible.</p>
<p>At B&#x113;hance, we have ~75 driver scripts, so you can likely imagine how slow a non-memoized version of this process would be.</p>
<p>The memoization works well because the trees are <em>serially</em> generated for each driver. I always lean towards parallelizing algorithms, but we&#x2019;d definitely risk race conditions here: where redundant tree generations occur because of one process didn&#x2019;t see a module in the cache right before another process added that module (and its tree) to the cache.</p>
<p><strong>Finding Relevant Entry Points</strong></p>
<p>The taxicab module coordinates steps 1 and 2. It creates the cache object that&#x2019;s used to memoize the tree generations across all drivers. We then loop through the trees looking for a particular module and collect the names of the drivers that have trees where the module is a member.</p>
<p>As currently described, this feature takes anywhere from ~35 to 50 seconds to complete about the B&#x113;hance codebase (around ~1000 JS modules). This is due to the app-root module; I need to dig deeper to see what&#x2019;s causing that. However, B&#x113;hance coincidentally uses AMD and RequireJS &#x2013; where it&#x2019;s possible to bypass programmatically finding the roots by supplying the RequireJS build configuration file. If you&#x2019;re unfamiliar, that json file is used by the rjs optimizer to build out the bundles. That file supports&#xA0;a &#x201C;modules&#x201D; list where you manually describe the bundles to generate (corresponding to entry points of your application).</p>
<p>With the list of modules from the build config, this process takes ~5s. So yeah, it&#x2019;s obvious where the ~30 to 45 second difference lies: app-root. Though, small codebases will still be fast and if your architecture is that of a single-bundle, you won&#x2019;t really find value in this feature.</p>
<p><strong>Shipped</strong></p>
<p>This feature works for all supported module types (AMD, CommonJS, ES6, and even SASS stylesheets) thanks to <a href="https://github.com/mrjoelkemp/node-precinct" target="_blank" rel="nofollow">precinct</a>. Now you&#x2019;ll be able to see which apps/features/pages will be affected by changes to a particular module.&#xA0;<a href="https://packagecontrol.io/packages/Dependents" target="_blank" rel="nofollow">Try it out</a> and feel free <a href="https://twitter.com/mrjoelkemp" target="_blank" rel="nofollow">let me know</a> what you think.</p>
<p>Cheers and thanks for reading!</p>
<h3>Comments</h3><p><comments-count href="http://mrjoelkemp.com/2015/01/javascript-knowing-which-apps-youre-breaking-using-static-analysis/"></comments-count> comments</p>		</div>
		
				
		
		
			</div><hr/><section id="articleList" style="font-size: 14px;"><b>Articles in This Issue</b><ul><li><a href="./ECMAScript 6: New OOP Features Besides Classes.html">ECMAScript 6: New OOP Features Besides Classes</a></li><li><a href="./Generation JavaScript.html">Generation JavaScript</a></li><li><a href="./New Course on JS.Next: ES6.html">New Course on JS.Next: ES6</a></li><li><a href="./<img src="http:--s3.amazonaws.com-nlga-uploads-item-image-31237-125.png" style="border: 0px solid #bbbbbb" width="104" height="104" alt="Frontend Masters">.html"><img src="http://s3.amazonaws.com/nlga/uploads/item/image/31237/125.png" style="border: 0px solid #bbbbbb" width="104" height="104" alt="Frontend Masters"></a></li><li><a href="./Symbols in ECMAScript 6.html">Symbols in ECMAScript 6</a></li><li><a href="./'JavaScript for Kids' Book Released in Print.html">'JavaScript for Kids' Book Released in Print</a></li><li><a href="./JSConf US 2015 Announced.html">JSConf US 2015 Announced</a></li><li><a href="./JavaScript developers - spend 60 seconds applying to 50 NYC jobs at once.html">JavaScript developers - spend 60 seconds applying to 50 NYC jobs at once</a></li><li><a href="./underdog.io..html">underdog.io.</a></li><li><a href="./An Opinionated Rundown of JS Frameworks.html">An Opinionated Rundown of JS Frameworks</a></li><li><a href="./5 Array Methods That You Should Be Using Now.html">5 Array Methods That You Should Be Using Now</a></li><li><a href="./45 Useful JavaScript Tips, Tricks and Best Practices.html">45 Useful JavaScript Tips, Tricks and Best Practices</a></li><li><a href="./Learning Much JavaScript From One Line of Code.html">Learning Much JavaScript From One Line of Code</a></li><li><a href="./All About Angular 2.0.html">All About Angular 2.0</a></li><li><a href="./18 Surprises From Reading jQuery's Source Code.html">18 Surprises From Reading jQuery's Source Code</a></li><li><a href="./jQuery 1.11.2 and 2.1.3 Released (Safari Fail-Safe Edition).html">jQuery 1.11.2 and 2.1.3 Released (Safari Fail-Safe Edition)</a></li><li><a href="./npm's Year in Numbers: 2014.html">npm's Year in Numbers: 2014</a></li><li><a href="./Some Obscure JavaScript Pitfalls.html">Some Obscure JavaScript Pitfalls</a></li><li><a href="./Exploring Facebook Flow: Facebook's Type Checker for JavaScript.html">Exploring Facebook Flow: Facebook's Type Checker for JavaScript</a></li><li><a href="./Knowing Which Apps You’re Breaking using Static Analysis.html">Knowing Which Apps You’re Breaking using Static Analysis</a></li><li><a href="./6 Easy Ways to Prevent Your Heroku Node App From Sleeping.html">6 Easy Ways to Prevent Your Heroku Node App From Sleeping</a></li><li><a href="./Creating Objects without Prototypes.html">Creating Objects without Prototypes</a></li><li><a href="./Converting A Project From AMD to CommonJS with Recast.html">Converting A Project From AMD to CommonJS with Recast</a></li><li><a href="./intellij-es67: ES6-7 Syntax Improvements Plugin for Inteliij IDEA.html">intellij-es67: ES6/7 Syntax Improvements Plugin for Inteliij IDEA</a></li><li><a href="./PleaseWait.js: A Loading-Splash Screen for your SPA.html">PleaseWait.js: A Loading/Splash Screen for your SPA</a></li><li><a href="./React Templates: Lightweight Templates for React.html">React Templates: Lightweight Templates for React</a></li><li><a href="./angular-websocket: AngularJS 1.x WebSocket Service for Connecting Client Apps to Servers.html">angular-websocket: AngularJS 1.x WebSocket Service for Connecting Client Apps to Servers</a></li><li><a href="./jsrt: A Simple JavaScript Ray Tracing Engine.html">jsrt: A Simple JavaScript Ray Tracing Engine</a></li><li><a href="./Rome: A Customizable Date (and Time) Picker Control.html">Rome: A Customizable Date (and Time) Picker Control</a></li><li><a href="./Bitcore: A Powerful JavaScript Core for Bitcoin Projects.html">Bitcore: A Powerful JavaScript Core for Bitcoin Projects</a></li></ul></section></div>